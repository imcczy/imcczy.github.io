---
layout: post
title:  "ART Dex加载"
date:   2017-07-02 16:36:33
categories: Android
tags: System
---
                        
                    



<h1 id="dex的加载过程">dex的加载过程</h1>

<p></p>

<p>这里的dex也包括oat文件。 <br>
启动应用时，<code>ActivityThread.java</code>中的<code>performLaunchActivity</code>函数：</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>{<br>        <span class="hljs-comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span><br><br>        ActivityInfo aInfo = r.activityInfo;<br>        <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-keyword">null</span>) {<br>            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,<br>                    Context.CONTEXT_INCLUDE_CODE);<span class="hljs-comment">//packageInfo是LoadApk类型，跟进</span><br>        }<br><br>       ……<br><br>        Activity activity = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();<span class="hljs-comment">//注意这里的getClassLoader函数</span><br></code></pre></div>

<p><code>getPackageInfo</code>函数返回一个<code>LoadedApk</code>对象，跟进该对象的<code>getClassLoader</code>函数：</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs">mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib,mBaseClassLoader);<br></code></pre></div>

<p>函数前面一大段都在准备<code>zip</code>和<code>lib</code>这两个参数 <br>
<code>getClassLoader</code>函数：</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs">PathClassLoader pathClassloader = <span class="hljs-keyword">new</span> PathClassLoader(zip, libPath, parent);<br></code></pre></div>

<p>可以看到<code>getClassLoader</code>函数最后调用了<code>PathClassLoader</code>。</p>

<p><code>PathClassLoader</code>和<code>DexClassLoader</code>都继承自<code>BaseDexClassLoader</code>，都是对父类简单的封装，<code>PathClassLoader</code>只能加载已安装的apk，对应的<code>zip</code>应该是oat的路径，同时<code>performLaunchActivity</code>调用链中的<code>optimizedDirectory</code>应该为null。同理，一些壳动态加载dex时，<code>optimizedDirectory</code>也是null，以避免oat的优化。直接让art解释运行。</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseDexClassLoader</span><span class="hljs-params">(String dexPath, File optimizedDirectory,String libraryPath, ClassLoader parent)</span> </span>{<br>        <span class="hljs-keyword">super</span>(parent);<br>        <span class="hljs-keyword">this</span>.pathList = <span class="hljs-keyword">new</span> DexPathList(<span class="hljs-keyword">this</span>, dexPath, libraryPath, optimizedDirectory);<br>    }<br></code></pre></div>

<p>跟进<code>DexPathList</code>的构造函数</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs"><span class="hljs-comment">/**<br>     * List of dex/resource (class path) elements.<br>     * Should be called pathElements, but the Facebook app uses reflection<br>     * to modify 'dexElements' (http://b/7726934).<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Element[] dexElements;<br><span class="hljs-keyword">this</span>.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory,<br>                                                suppressedExceptions);<br></code></pre></div>

<p>跟进<code>makePathElements</code></p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs"><span class="hljs-keyword">if</span> (path.contains(zipSeparator)) {<br>                String split[] = path.split(zipSeparator, <span class="hljs-number">2</span>);<br>                zip = <span class="hljs-keyword">new</span> File(split[<span class="hljs-number">0</span>]);<br>                dir = <span class="hljs-keyword">new</span> File(split[<span class="hljs-number">1</span>]);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDirectory()) {<br>                <span class="hljs-comment">// We support directories for looking up resources and native libraries.</span><br>                <span class="hljs-comment">// Looking up resources in directories is useful for running libcore tests.</span><br>                elements.add(<span class="hljs-keyword">new</span> Element(file, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>));<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isFile()) {<br>                <span class="hljs-keyword">if</span> (name.endsWith(DEX_SUFFIX)) {<span class="hljs-comment">//".dex"</span><br>                    <span class="hljs-comment">// Raw dex file (not inside a zip/jar).</span><br>                    <span class="hljs-keyword">try</span> {<br>                        dex = loadDexFile(file, optimizedDirectory);<br>                    } <span class="hljs-keyword">catch</span> (IOException ex) {<br>                        System.logE(<span class="hljs-string">"Unable to load dex file: "</span> + file, ex);<br>                    }<br>                } <span class="hljs-keyword">else</span> {<br>                    zip = file;<br><br>                    <span class="hljs-keyword">try</span> {<br>                        dex = loadDexFile(file, optimizedDirectory);<br>                    } <span class="hljs-keyword">catch</span> (IOException suppressed) {<br></code></pre></div>

<p>如果是dex结尾，则调用<code>loadDexFile</code>函数</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DexFile <span class="hljs-title">loadDexFile</span><span class="hljs-params">(File file, File optimizedDirectory)</span><br>            <span class="hljs-keyword">throws</span> IOException </span>{<br>        <span class="hljs-keyword">if</span> (optimizedDirectory == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DexFile(file);<br>        } <span class="hljs-keyword">else</span> {<br>            String optimizedPath = optimizedPathFor(file, optimizedDirectory);<br>            <span class="hljs-keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="hljs-number">0</span>);<br>        }<br>    }<br></code></pre></div>

<p>这里对<code>optimizedDirectory</code>是否为null做了不同的处理，最后两者都调用了<code>openDexFile(sourceName, outputName, flags);</code>返回 <code>magic VM cookie</code>，<code>outputName</code>即<code>optimizedDirectory</code>。 <br>
<code>openDexFile</code>调用了：</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-java hljs">openDexFileNative(<span class="hljs-keyword">new</span> File(sourceName).getAbsolutePath(),(outputName == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> File(outputName).getAbsolutePath(),flags);<br></code></pre></div>

<p><code>openDexFileNative</code>是一个native函数，在</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="hljs gradle"><span class="hljs-regexp">/art/</span><span class="hljs-keyword">runtime</span><span class="hljs-regexp">/native/</span>dalvik_system_DexFile.cc<br></code></pre></div>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> jobject <span class="hljs-title">DexFile_openDexFileNative</span><span class="hljs-params">(<br>    JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint)</span> </span>{<br>  <span class="hljs-function">ScopedUtfChars <span class="hljs-title">sourceName</span><span class="hljs-params">(env, javaSourceName)</span></span>;<br>  <span class="hljs-keyword">if</span> (sourceName.c_str() == <span class="hljs-literal">nullptr</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<br>  <span class="hljs-function">NullableScopedUtfChars <span class="hljs-title">outputName</span><span class="hljs-params">(env, javaOutputName)</span></span>;<br>  <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<br><br>  ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt;&gt; dex_files;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; error_msgs;<br><br>  dex_files = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs);<br><br>  ……<br></code></pre></div>

<p>调用了<code>openDexFilesFromOat</code>进行加载</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt;&gt; ClassLinker::OpenDexFilesFromOat(<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* dex_location, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* oat_location,<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;* error_msgs) {<br>  CHECK(error_msgs != <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-comment">// Verify we aren't holding the mutator lock, which could starve GC if we</span><br>  <span class="hljs-comment">// have to generate or relocate an oat file.</span><br>  Locks::mutator_lock_-&gt;AssertNotHeld(Thread::Current());<br><br>  <span class="hljs-function">OatFileAssistant <span class="hljs-title">oat_file_assistant</span><span class="hljs-params">(dex_location, oat_location, kRuntimeISA,<br>     !Runtime::Current()</span>-&gt;<span class="hljs-title">IsAotCompiler</span><span class="hljs-params">()</span>)</span>;<br><br>  <span class="hljs-comment">// Lock the target oat location to avoid races generating and loading the</span><br>  <span class="hljs-comment">// oat file.</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> error_msg;<br>  <span class="hljs-keyword">if</span> (!oat_file_assistant.Lock(&amp;error_msg)) {<br>    <span class="hljs-comment">// Don't worry too much if this fails. If it does fail, it's unlikely we</span><br>    <span class="hljs-comment">// can generate an oat file anyway.</span><br>    VLOG(class_linker) &lt;&lt; <span class="hljs-string">"OatFileAssistant::Lock: "</span> &lt;&lt; error_msg;<br>  }<br><br>  <span class="hljs-comment">// Check if we already have an up-to-date oat file open.</span><br>  <span class="hljs-keyword">const</span> OatFile* source_oat_file = <span class="hljs-literal">nullptr</span>;<br>  {<br>    <span class="hljs-function">ReaderMutexLock <span class="hljs-title">mu</span><span class="hljs-params">(Thread::Current()</span>, dex_lock_)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> OatFile* oat_file : oat_files_) {<br>      CHECK(oat_file != <span class="hljs-literal">nullptr</span>);<br>      <span class="hljs-keyword">if</span> (oat_file_assistant.GivenOatFileIsUpToDate(*oat_file)) {<br>        source_oat_file = oat_file;<br>        <span class="hljs-keyword">break</span>;<br>      } }}<br>  <span class="hljs-comment">// If we didn't have an up-to-date oat file open, try to load one from disk.</span><br>  <span class="hljs-keyword">if</span> (source_oat_file == <span class="hljs-literal">nullptr</span>) {<br>    <span class="hljs-comment">// Update the oat file on disk if we can. This may fail, but that's okay.</span><br>    <span class="hljs-comment">// Best effort is all that matters here.</span><br>    <span class="hljs-keyword">if</span> (!oat_file_assistant.MakeUpToDate(&amp;error_msg)) {<br>      LOG(WARNING) &lt;&lt; error_msg;<br>    }<br><br>    <span class="hljs-comment">// Get the oat file on disk.</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;OatFile&gt; oat_file = oat_file_assistant.GetBestOatFile();<br>    <span class="hljs-keyword">if</span> (oat_file.get() != <span class="hljs-literal">nullptr</span>) {<br>      <span class="hljs-comment">// Take the file only if it has no collisions, or we must take it because of preopting.</span><br>      <span class="hljs-keyword">bool</span> accept_oat_file = !HasCollisions(oat_file.get(), &amp;error_msg);<br>      <span class="hljs-keyword">if</span> (!accept_oat_file) {<br>        <span class="hljs-comment">// Failed the collision check. Print warning.</span><br>        <span class="hljs-keyword">if</span> (Runtime::Current()-&gt;IsDexFileFallbackEnabled()) {<br>          LOG(WARNING) &lt;&lt; <span class="hljs-string">"Found duplicate classes, falling back to interpreter mode for "</span><br>                       &lt;&lt; dex_location;<br>        } <span class="hljs-keyword">else</span> {<br>          LOG(WARNING) &lt;&lt; <span class="hljs-string">"Found duplicate classes, dex-file-fallback disabled, will be failing to load classes for "</span> &lt;&lt; dex_location;<br>        }<br>        LOG(WARNING) &lt;&lt; error_msg;<br><br>        <span class="hljs-comment">// However, if the app was part of /system and preopted, there is no original dex file</span><br>        <span class="hljs-comment">// available. In that case grudgingly accept the oat file.</span><br>        <span class="hljs-keyword">if</span> (!DexFile::MaybeDex(dex_location)) {<br>          accept_oat_file = <span class="hljs-literal">true</span>;<br>          LOG(WARNING) &lt;&lt; <span class="hljs-string">"Dex location "</span> &lt;&lt; dex_location &lt;&lt; <span class="hljs-string">" does not seem to include dex file. "</span>&lt;&lt; <span class="hljs-string">"Allow oat file use. This is potentially dangerous."</span>;<br>        }}<br>      <span class="hljs-keyword">if</span> (accept_oat_file) {<br>        source_oat_file = oat_file.release();<br>        RegisterOatFile(source_oat_file);<br>      } }}<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt;&gt; dex_files;<br><br>  <span class="hljs-comment">// Load the dex files from the oat file.</span><br>  <span class="hljs-keyword">if</span> (source_oat_file != <span class="hljs-literal">nullptr</span>) {<br>    dex_files = oat_file_assistant.LoadDexFiles(*source_oat_file, dex_location);<br>    <span class="hljs-keyword">if</span> (dex_files.empty()) {<br>      error_msgs-&gt;push_back(<span class="hljs-string">"Failed to open dex files from "</span><br>          + source_oat_file-&gt;GetLocation());<br>    }}<br>  <span class="hljs-comment">// Fall back to running out of the original dex file if we couldn't load any</span><br>  <span class="hljs-comment">// dex_files from the oat file.</span><br>  <span class="hljs-keyword">if</span> (dex_files.empty()) {<br>    <span class="hljs-keyword">if</span> (oat_file_assistant.HasOriginalDexFiles()) {<br>      <span class="hljs-keyword">if</span> (Runtime::Current()-&gt;IsDexFileFallbackEnabled()) {<br>        <span class="hljs-keyword">if</span> (!DexFile::Open(dex_location, dex_location, &amp;error_msg, &amp;dex_files)) {<br>          LOG(WARNING) &lt;&lt; error_msg;<br>          error_msgs-&gt;push_back(<span class="hljs-string">"Failed to open dex files from "</span> + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(dex_location));<br>        }<br>      } <span class="hljs-keyword">else</span> {<br>        error_msgs-&gt;push_back(<span class="hljs-string">"Fallback mode disabled, skipping dex files."</span>);<br>      }<br>    } <span class="hljs-keyword">else</span> {<br>      error_msgs-&gt;push_back(<span class="hljs-string">"No original dex files found for dex location "</span><br>          + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(dex_location));<br>    }}<br>  <span class="hljs-keyword">return</span> dex_files;<br>}<br></code></pre></div>

<p>先构造一个<code>OatFileAssistant</code>对象，用于辅助从OAT文件中加载DEX。 <br>
假设我们是第一次加载没有oat文件，则先后调用<code>MakeUpToDate</code>函数和<code>GetBaseOatFiles</code>函数</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs"><span class="hljs-keyword">bool</span> OatFileAssistant::MakeUpToDate(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg) {<br>  <span class="hljs-keyword">switch</span> (GetDexOptNeeded()) {<br>    <span class="hljs-keyword">case</span> kNoDexOptNeeded: <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">case</span> kDex2OatNeeded: <span class="hljs-keyword">return</span> GenerateOatFile(error_msg);<br>    <span class="hljs-keyword">case</span> kPatchOatNeeded: <span class="hljs-keyword">return</span> RelocateOatFile(OdexFileName(), error_msg);<br>    <span class="hljs-keyword">case</span> kSelfPatchOatNeeded: <span class="hljs-keyword">return</span> RelocateOatFile(OatFileName(), error_msg);<br>  }<br>  UNREACHABLE();<br>}<br><br>OatFileAssistant::DexOptNeeded OatFileAssistant::GetDexOptNeeded() {<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If the profiling code is ever restored, it's worth considering</span><br>  <span class="hljs-comment">// whether we should check to see if the profile is out of date here.</span><br><br>  <span class="hljs-keyword">if</span> (OatFileIsUpToDate() || OdexFileIsUpToDate()) {<br>    <span class="hljs-keyword">return</span> kNoDexOptNeeded;<br>  }<br><br>  <span class="hljs-keyword">if</span> (OdexFileNeedsRelocation()) {<br>    <span class="hljs-keyword">return</span> kPatchOatNeeded;<br>  }<br><br>  <span class="hljs-keyword">if</span> (OatFileNeedsRelocation()) {<br>    <span class="hljs-keyword">return</span> kSelfPatchOatNeeded;<br>  }<br><br>  <span class="hljs-keyword">return</span> HasOriginalDexFiles() ? kDex2OatNeeded : kNoDexOptNeeded;<br>}<br></code></pre></div>

<p>如果oat存在，<code>GetDexOptNeeded</code>最后会加载oat文件，我们这里返回<code>kDex2OatNeeded</code>，即oat不存在，调用<code>GenerateOatFile</code></p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs"><span class="hljs-keyword">bool</span> OatFileAssistant::GenerateOatFile(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg) {<br>  CHECK(error_msg != <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-keyword">if</span> (OatFileName() == <span class="hljs-literal">nullptr</span>) {<br>    *error_msg = <span class="hljs-string">"Generation of oat file for dex location "</span><br>      + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(dex_location_)<br>      + <span class="hljs-string">" not attempted because the oat file name could not be determined."</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; oat_file_name = *OatFileName();<br><br>  Runtime* runtime = Runtime::Current();<br>  <span class="hljs-keyword">if</span> (!runtime-&gt;IsDex2OatEnabled()) {<br>    *error_msg = <span class="hljs-string">"Generation of oat file "</span> + oat_file_name<br>      + <span class="hljs-string">" not attempted because dex2oat is disabled"</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; args;<br>  args.push_back(<span class="hljs-string">"--dex-file="</span> + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(dex_location_));<br>  args.push_back(<span class="hljs-string">"--oat-file="</span> + oat_file_name);<br><br>  <span class="hljs-comment">// dex2oat ignores missing dex files and doesn't report an error.</span><br>  <span class="hljs-comment">// Check explicitly here so we can detect the error properly.</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Why does dex2oat behave that way?</span><br>  <span class="hljs-keyword">if</span> (!OS::FileExists(dex_location_)) {<br>    *error_msg = <span class="hljs-string">"Dex location "</span> + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(dex_location_) + <span class="hljs-string">" does not exists."</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> (!Dex2Oat(args, error_msg)) {<br>    <span class="hljs-comment">// Manually delete the file. This ensures there is no garbage left over if</span><br>    <span class="hljs-comment">// the process unexpectedly died.</span><br>    TEMP_FAILURE_RETRY(unlink(oat_file_name.c_str()));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br><br>  <span class="hljs-comment">// Mark that the oat file has changed and we should try to reload.</span><br>  ClearOatFileCache();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></div>

<p>如果<code>OatFileName()</code>不为空，则调用<code>dex2oat</code>，但是动态加载的情况下，<code>OatFileName()</code>为空，停止编译oat，再看<code>GetBaseOatFiles</code>函数，因为没有对应的OAT文件，所以最终返回空指针。回到<code>openDexFilesFromOat</code>，此时<code>if (dex_files.empty())</code>分支条件成立进入<code>DexFile::Open(dex_location, dex_location, &amp;error_msg, &amp;dex_files)</code></p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs"><span class="hljs-keyword">bool</span> DexFile::Open(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* location, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg,<br>                   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt;&gt;* dex_files) {<br>  DCHECK(dex_files != <span class="hljs-literal">nullptr</span>) &lt;&lt; <span class="hljs-string">"DexFile::Open: out-param is nullptr"</span>;<br>  <span class="hljs-keyword">uint32_t</span> magic;<br>  <span class="hljs-function">ScopedFd <span class="hljs-title">fd</span><span class="hljs-params">(OpenAndReadMagic(filename, &amp;magic, error_msg)</span>)</span>;<br>  <span class="hljs-keyword">if</span> (fd.get() == <span class="hljs-number">-1</span>) {<br>    DCHECK(!error_msg-&gt;empty());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  }<br>  <span class="hljs-keyword">if</span> (IsZipMagic(magic)) {<br>    <span class="hljs-keyword">return</span> DexFile::OpenZip(fd.release(), location, error_msg, dex_files);<br>  }<br>  <span class="hljs-keyword">if</span> (IsDexMagic(magic)) {<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt; dex_file(DexFile::OpenFile(fd.release(), location, <span class="hljs-literal">true</span>,error_msg));<br>    <span class="hljs-keyword">if</span> (dex_file.get() != <span class="hljs-literal">nullptr</span>) {<br>      dex_files-&gt;push_back(<span class="hljs-built_in">std</span>::move(dex_file));<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }}<br>  *error_msg = StringPrintf(<span class="hljs-string">"Expected valid zip or dex file: '%s'"</span>, filename);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></div>

<p>可以看到调用了<code>DexFile::OpenFile(fd.release(), location, true,error_msg)</code></p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt; DexFile::OpenFile(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* location, <span class="hljs-keyword">bool</span> verify,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg) {<br>  CHECK(location != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;MemMap&gt; <span class="hljs-built_in">map</span>;<br>  {<br>    <span class="hljs-function">ScopedFd <span class="hljs-title">delayed_close</span><span class="hljs-params">(fd)</span></span>;<br>    <span class="hljs-keyword">struct</span> stat sbuf;<br>    <span class="hljs-built_in">memset</span>(&amp;sbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sbuf));<br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;sbuf) == <span class="hljs-number">-1</span>) {<br>      *error_msg = StringPrintf(<span class="hljs-string">"DexFile: fstat '%s' failed: %s"</span>, location, strerror(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (S_ISDIR(sbuf.st_mode)) {<br>      *error_msg = StringPrintf(<span class="hljs-string">"Attempt to mmap directory '%s'"</span>, location);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    }<br>    <span class="hljs-keyword">size_t</span> length = sbuf.st_size;<br>    <span class="hljs-built_in">map</span>.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>, location, error_msg));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.get() == <span class="hljs-literal">nullptr</span>) {<br>      DCHECK(!error_msg-&gt;empty());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    }<br>  }<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;Size() &lt; <span class="hljs-keyword">sizeof</span>(DexFile::Header)) {<br>    *error_msg = StringPrintf(<br>        <span class="hljs-string">"DexFile: failed to open dex file '%s' that is too short to have a header"</span>, location);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  }<br><br>  <span class="hljs-keyword">const</span> Header* dex_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> Header*&gt;(<span class="hljs-built_in">map</span>-&gt;Begin());<br><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt; dex_file(OpenMemory(location, dex_header-&gt;checksum_, <span class="hljs-built_in">map</span>.release(),error_msg));<br>  <span class="hljs-keyword">if</span> (dex_file.get() == <span class="hljs-literal">nullptr</span>) {<br>    *error_msg = StringPrintf(<span class="hljs-string">"Failed to open dex file '%s' from memory: %s"</span>, location,error_msg-&gt;c_str());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  }<br><br>  <span class="hljs-keyword">if</span> (verify &amp;&amp; !DexFileVerifier::Verify(dex_file.get(), dex_file-&gt;Begin(), dex_file-&gt;Size(),location, error_msg)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  }<br>  <span class="hljs-keyword">return</span> dex_file;<br>}<br></code></pre></div>

<p>继续调用<code>OpenMemory(location, dex_header-&gt;checksum_, map.release(), error_msg)</code>，继而</p>



<div class="language-cpp highlighter-rouge"><pre class="highlight"><code class="language-cpp hljs">OpenMemory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* base,<br>           <span class="hljs-keyword">size_t</span> size,<br>           <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,<br>           <span class="hljs-keyword">uint32_t</span> location_checksum,<br>           MemMap* mem_map,<br>           <span class="hljs-keyword">const</span> OatDexFile* oat_dex_file,<br>           <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)<br></code></pre></div>

<p>注意这里最终的<code>openMemory</code>的参数是7个，实际上linker二进制当中的是8个，，<code>openMemory</code>最后调用了<code>DexFile</code>的构造函数并返回。</p>